Index: linux-5.15.167/drivers/leds/leds-gpio.c
===================================================================
--- linux-5.15.167.orig/drivers/leds/leds-gpio.c
+++ linux-5.15.167/drivers/leds/leds-gpio.c
@@ -16,8 +16,12 @@
 #include <linux/platform_device.h>
 #include <linux/property.h>
 #include <linux/slab.h>
+#include <linux/sysfs-mnfinfo.h>
 #include "leds.h"
 
+#define COMPATIBLE_MODEL_MAX_SIZE 10
+#define MODEL_NAME_LENGTH 6
+
 struct gpio_led_data {
 	struct led_classdev cdev;
 	struct gpio_desc *gpiod;
@@ -132,6 +136,9 @@ static struct gpio_leds_priv *gpio_leds_
 	struct device *dev = &pdev->dev;
 	struct fwnode_handle *child;
 	struct gpio_leds_priv *priv;
+	const char **compatible_models = NULL;
+	const char *tlt_name;
+	char *short_name = NULL;
 	int count, ret;
 
 	count = device_get_child_node_count(dev);
@@ -142,21 +149,44 @@ static struct gpio_leds_priv *gpio_leds_
 	if (!priv)
 		return ERR_PTR(-ENOMEM);
 
+	tlt_name = mnf_info_get_device_name();
+	if (tlt_name) {
+		compatible_models = kzalloc(COMPATIBLE_MODEL_MAX_SIZE * sizeof(char *), GFP_KERNEL);
+		short_name = kzalloc(MODEL_NAME_LENGTH + 1, GFP_KERNEL);
+		strncpy(short_name, tlt_name, MODEL_NAME_LENGTH);
+		short_name[6] = '\0';
+	}
+
 	device_for_each_child_node(dev, child) {
 		struct gpio_led_data *led_dat = &priv->leds[priv->num_leds];
 		struct gpio_led led = {};
+		char index = 0;
 
+		if (short_name && fwnode_property_present(child, "compatible_models")) {
+			count = fwnode_property_read_string_array(child, "compatible_models", compatible_models, COMPATIBLE_MODEL_MAX_SIZE);
+			if (count > 0) {
+				for (int i = 0; i < count; i++) {
+					if (strstr(compatible_models[i], short_name)) {
+						index = i;
+						goto create_led;
+					}
+				}
+				continue;
+			}
+		}
+create_led:
 		/*
 		 * Acquire gpiod from DT with uninitialized label, which
 		 * will be updated after LED class device is registered,
 		 * Only then the final LED name is known.
 		 */
-		led.gpiod = devm_fwnode_get_gpiod_from_child(dev, NULL, child,
+		led.gpiod = devm_fwnode_get_index_gpiod_from_child(dev, NULL, index, child,
 							     GPIOD_ASIS,
 							     NULL);
 		if (IS_ERR(led.gpiod)) {
 			fwnode_handle_put(child);
-			return ERR_CAST(led.gpiod);
+			priv = ERR_CAST(led.gpiod);
+			goto cleanup;
 		}
 
 		led_dat->gpiod = led.gpiod;
@@ -173,7 +203,8 @@ static struct gpio_leds_priv *gpio_leds_
 		ret = create_gpio_led(&led, led_dat, dev, child, NULL);
 		if (ret < 0) {
 			fwnode_handle_put(child);
-			return ERR_PTR(ret);
+			priv = ERR_PTR(ret);
+			goto cleanup;
 		}
 		/* Set gpiod label to match the corresponding LED name. */
 		gpiod_set_consumer_name(led_dat->gpiod,
@@ -181,6 +212,13 @@ static struct gpio_leds_priv *gpio_leds_
 		priv->num_leds++;
 	}
 
+cleanup:
+	if (short_name)
+		kfree(short_name);
+
+	if (compatible_models)
+		kfree(compatible_models);
+
 	return priv;
 }
 
