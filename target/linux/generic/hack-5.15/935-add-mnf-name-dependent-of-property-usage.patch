Index: linux-5.15.165/drivers/gpio/gpiolib-of.c
===================================================================
--- linux-5.15.165.orig/drivers/gpio/gpiolib-of.c
+++ linux-5.15.165/drivers/gpio/gpiolib-of.c
@@ -1125,6 +1125,7 @@ static int of_gpio_export_probe(struct p
 {
 	struct device_node *np = pdev->dev.of_node;
 	struct device_node *cnp;
+	const struct property *prop;
 	u32 val;
 	int nb = 0, ret;
 
@@ -1135,6 +1136,18 @@ static int of_gpio_export_probe(struct p
 		int max_gpio = 1;
 		int i;
 
+		prop = of_find_property(cnp, "tlt-mnf,device", NULL);
+		if (prop && !of_mnf_name_is_compatible(prop))
+			continue;
+
+		prop = of_find_property(cnp, "tlt-mnf,branch", NULL);
+		if (prop && !of_mnf_branch_is_compatible(prop))
+			continue;
+
+		prop = of_find_property(cnp, "tlt-mnf,hwver", NULL);
+		if (prop && !of_mnf_hwver_is_compatible(cnp))
+			continue;
+
 		of_property_read_string(cnp, "gpio-export,name", &name);
 
 		if (!name)
Index: linux-5.15.165/drivers/of/base.c
===================================================================
--- linux-5.15.165.orig/drivers/of/base.c
+++ linux-5.15.165/drivers/of/base.c
@@ -28,7 +28,8 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/proc_fs.h>
-
+#include <linux/init.h>
+#include <linux/sysfs-mnfinfo.h>
 #include "of_private.h"
 
 LIST_HEAD(aliases_lookup);
@@ -56,6 +57,27 @@ DEFINE_MUTEX(of_mutex);
  */
 DEFINE_RAW_SPINLOCK(devtree_lock);
 
+char mnf_device_name[16] __initdata = "";
+char mnf_device_hwver[16] __initdata = "";
+
+static int __init mnf_device_setup(char *str)
+{
+	if (str) {
+		strlcpy(mnf_device_name, str, sizeof(mnf_device_name));
+	}
+	return 1;
+}
+__setup("device=", mnf_device_setup);
+
+static int __init mnf_hwver_setup(char *str)
+{
+	if (str) {
+		strlcpy(mnf_device_hwver, str, sizeof(mnf_device_hwver));
+	}
+	return 1;
+}
+__setup("hwver=", mnf_hwver_setup);
+
 bool of_node_name_eq(const struct device_node *np, const char *name)
 {
 	const char *node_name;
@@ -579,6 +601,85 @@ int of_machine_is_compatible(const char
 }
 EXPORT_SYMBOL(of_machine_is_compatible);
 
+bool of_mnf_name_is_compatible(const struct property *prop) {
+	size_t l;
+	int i;
+	const char *p, *end;
+
+	if (!prop->value)
+		return false;
+
+	if (strlen(mnf_device_name) == 0) {
+		if (!(p = mnf_info_get_device_name()))
+			return false;
+		strlcpy(mnf_device_name, p,16);
+	}
+
+	p = prop->value;
+	end = p + prop->length;
+
+	for (i = 0; p < end; i++, p += l) {
+		l = strnlen(p, end - p) + 1;
+		if (p + l > end)
+			return false;
+		if (strstr(mnf_device_name, p))
+			return true; /* Found it */
+	}
+	return false;
+}
+EXPORT_SYMBOL(of_mnf_name_is_compatible);
+
+bool of_mnf_branch_is_compatible(const struct property *prop) {
+	size_t l;
+	int i;
+	const char *p, *end;
+	static char branch[5] = {0};
+	if (!prop->value)
+		return false;
+
+	if (strlen(branch) == 0) {
+		if (!(p = mnf_info_get_branch()))
+			return false;
+		strlcpy(branch, p,4);
+	}
+
+	p = prop->value;
+	end = p + prop->length;
+
+	for (i = 0; p < end; i++, p += l) {
+		l = strnlen(p, end - p) + 1;
+		if (p + l > end)
+			return false;
+		if (strstr(branch, p))
+			return true; /* Found it */
+	}
+	return false;
+}
+EXPORT_SYMBOL(of_mnf_branch_is_compatible);
+
+bool of_mnf_hwver_is_compatible(const struct device_node *device) {
+	static long int cur_hwver = 0;
+	unsigned int arr_hwver[2];
+	const char *p;
+
+	if (cur_hwver == 0) {
+		if (kstrtol(mnf_device_hwver, 10, &cur_hwver) != 0) {
+			if (!(p = mnf_info_get_hw_version())) return false;
+			if (kstrtol(p, 10, &cur_hwver) != 0) return false;
+		}
+		if (cur_hwver > 99) cur_hwver %= 100;
+		if (cur_hwver == 0) return true;
+	}
+
+	if (of_property_read_u32_array(device, "tlt-mnf,hwver", arr_hwver, 2) == 0) {
+		if (arr_hwver[0] <= cur_hwver && cur_hwver <= arr_hwver[1])
+			return true; /* Compatible */
+	}
+	return false;
+}
+EXPORT_SYMBOL(of_mnf_hwver_is_compatible);
+
+
 /**
  *  __of_device_is_available - check if a device is available for use
  *
@@ -591,10 +692,23 @@ static bool __of_device_is_available(con
 {
 	const char *status;
 	int statlen;
+	const struct property *prop;
 
 	if (!device)
 		return false;
 
+	prop = __of_find_property(device, "tlt-mnf,device" , NULL);
+	if (prop && !of_mnf_name_is_compatible(prop))
+		return false;
+
+	prop = __of_find_property(device, "tlt-mnf,branch" , NULL);
+	if (prop && !of_mnf_branch_is_compatible(prop))
+		return false;
+
+	prop = __of_find_property(device, "tlt-mnf,hwver" , NULL);
+	if (prop && !of_mnf_hwver_is_compatible(device))
+		return false;
+
 	status = __of_get_property(device, "status", &statlen);
 	if (status == NULL)
 		return true;
@@ -606,7 +720,6 @@ static bool __of_device_is_available(con
 
 	return false;
 }
-
 /**
  *  of_device_is_available - check if a device is available for use
  *
Index: linux-5.15.165/include/linux/of.h
===================================================================
--- linux-5.15.165.orig/include/linux/of.h
+++ linux-5.15.165/include/linux/of.h
@@ -412,6 +412,10 @@ extern int of_update_property(struct dev
 extern int of_attach_node(struct device_node *);
 extern int of_detach_node(struct device_node *);
 
+extern bool of_mnf_name_is_compatible(const struct property *prop);
+extern bool of_mnf_branch_is_compatible(const struct property *prop);
+extern bool of_mnf_hwver_is_compatible(const struct device_node *device);
+
 #define of_match_ptr(_ptr)	(_ptr)
 
 /*
Index: linux-5.15.165/include/linux/sysfs-mnfinfo.h
===================================================================
--- linux-5.15.165.orig/include/linux/sysfs-mnfinfo.h
+++ linux-5.15.165/include/linux/sysfs-mnfinfo.h
@@ -5,5 +5,6 @@
 const char *mnf_info_get_device_name(void);
 const char *mnf_info_get_hw_version(void);
 const char *mnf_info_get_batch(void);
+const char *mnf_info_get_branch(void);
 
 #endif
